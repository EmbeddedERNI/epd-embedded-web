

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Heap Memory Debugging &mdash; ESP-IDF Programming Guide v3.0-dev-806-gde750e9 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="author" title="About these documents"
              href="../../about.html"/>
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="ESP-IDF Programming Guide v3.0-dev-806-gde750e9 documentation" href="../../index.html"/>
        <link rel="up" title="System API" href="index.html"/>
        <link rel="next" title="Interrupt allocation" href="intr_alloc.html"/>
        <link rel="prev" title="Heap Memory Allocation" href="mem_alloc.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> ESP-IDF Programming Guide
          

          
          </a>

          
            
            
              <div class="version">
                v3.0-dev-806-gde750e9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../wifi/index.html">Wi-Fi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ethernet/index.html">Ethernet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">Heap Memory Allocation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="heap_debug.html#">Heap Memory Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="heap_debug.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="heap_debug.html#heap-information">Heap Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="heap_debug.html#heap-corruption-detection">Heap Corruption Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="heap_debug.html#heap-tracing">Heap Tracing</a></li>
<li class="toctree-l4"><a class="reference internal" href="heap_debug.html#api-reference-heap-tracing">API Reference - Heap Tracing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="base_mac_address.html">Base MAC address</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Configuration Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">H/W Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">API Reference</a> &raquo;</li>
        
          <li><a href="index.html">System API</a> &raquo;</li>
        
      <li>Heap Memory Debugging</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/api-reference/system/heap_debug.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="heap-memory-debugging">
<h1>Heap Memory Debugging<a class="headerlink" href="heap_debug.html#heap-memory-debugging" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="heap_debug.html#overview" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF integrates tools for requesting <a class="reference internal" href="heap_debug.html#id1">heap information</a>, <a class="reference external" href="https://dl.espressif.com/doc/esp-idf/latest/api-reference/system/heapcorruptiondetection">detecting heap corruption</a>, and <a class="reference external" href="https://dl.espressif.com/doc/esp-idf/latest/api-reference/system/heaptracing">tracing memory leaks</a>. These can help track down memory-related bugs.</p>
<p>For general information about the heap memory allocator, see the <a class="reference internal" href="mem_alloc.html"><span class="doc">Heap Memory Allocation</span></a> page.</p>
</div>
<div class="section" id="heap-information">
<span id="id1"></span><h2>Heap Information<a class="headerlink" href="heap_debug.html#heap-information" title="Permalink to this headline">¶</a></h2>
<p>To obtain information about the state of the heap:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xPortGetFreeHeapSize()</span></code> is a FreeRTOS function which returns the number of free bytes in the (data memory) heap. This is equivalent to <code class="docutils literal"><span class="pre">heap_caps_get_free_size(MALLOC_CAP_8BIT)</span></code>.</li>
<li><code class="docutils literal"><span class="pre">heap_caps_get_free_size()</span></code> can also be used to return the current free memory for different memory capabilities.</li>
<li><code class="docutils literal"><span class="pre">heap_caps_get_largest_free_block()</span></code> can be used to return the largest free block in the heap. This is the largest single allocation which is currently possible. Tracking this value and comparing to total free heap allows you to detect heap fragmentation.</li>
<li><code class="docutils literal"><span class="pre">xPortGetMinimumEverFreeHeapSize()</span></code> and the related <code class="docutils literal"><span class="pre">heap_caps_get_minimum_free_size()</span></code> can be used to track the heap &#8220;low water mark&#8221; since boot.</li>
<li><code class="docutils literal"><span class="pre">heap_caps_get_info</span></code> returns a <code class="docutils literal"><span class="pre">multi_heap_info_t</span></code> structure which contains the information from the above functions, plus some additional heap-specific data (number of allocations, etc.)</li>
</ul>
</div>
<div class="section" id="heap-corruption-detection">
<span id="heap-corruption"></span><h2>Heap Corruption Detection<a class="headerlink" href="heap_debug.html#heap-corruption-detection" title="Permalink to this headline">¶</a></h2>
<p>Heap corruption detection allows you to detect various types of heap memory errors:</p>
<ul class="simple">
<li>Out of bounds writes &amp; buffer overflow.</li>
<li>Writes to freed memory.</li>
<li>Reads from freed or uninitialized memory,</li>
</ul>
<div class="section" id="assertions">
<h3>Assertions<a class="headerlink" href="heap_debug.html#assertions" title="Permalink to this headline">¶</a></h3>
<p>The heap implementation (<code class="docutils literal"><span class="pre">multi_heap.c</span></code>, etc.) includes a lot of assertions which will fail if the heap memory is corrupted. To detect heap corruption most effectively, ensure that assertions are enabled in <code class="docutils literal"><span class="pre">make</span> <span class="pre">menuconfig</span></code> under <code class="docutils literal"><span class="pre">Compiler</span> <span class="pre">options</span></code>.</p>
<p>If a heap integrity assertion fails, a line will be printed like <code class="docutils literal"><span class="pre">CORRUPT</span> <span class="pre">HEAP:</span> <span class="pre">multi_heap.c:225</span> <span class="pre">detected</span> <span class="pre">at</span> <span class="pre">0x3ffbb71c</span></code>. The memory address which is printed is the address of the heap structure which has corrupt content.</p>
<p>It&#8217;s also possible to manually check heap integrity by calling the <code class="docutils literal"><span class="pre">heap_caps_check_integrity()</span></code> function (see below). This function checks all of requested heap memory for integrity, and can be used even if assertions are disabled. If the integrity check prints an error, it will contain the address(es) of corrupt heap structures.</p>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="heap_debug.html#configuration" title="Permalink to this headline">¶</a></h3>
<p>In <code class="docutils literal"><span class="pre">make</span> <span class="pre">menuconfig</span></code>, under <code class="docutils literal"><span class="pre">Component</span> <span class="pre">config</span></code> there is a menu <code class="docutils literal"><span class="pre">Heap</span> <span class="pre">memory</span> <span class="pre">debugging</span></code>. The setting <code class="docutils literal"><span class="pre">Heap</span> <span class="pre">corruption</span> <span class="pre">detection</span></code> can be set to one of three levels:</p>
</div>
<div class="section" id="basic-no-poisoning">
<h3>Basic (no poisoning)<a class="headerlink" href="heap_debug.html#basic-no-poisoning" title="Permalink to this headline">¶</a></h3>
<p>This is the default level. No special heap corruption features are enabled, but checks will fail if any of the heap&#8217;s internal data structures are overwritten or corrupted. This usually indicates a buffer overrun or out of bounds write.</p>
<p>If assertions are enabled, an assertion will also trigger if a double-free occurs (ie the same memory is freed twice).</p>
</div>
<div class="section" id="light-impact">
<h3>Light impact<a class="headerlink" href="heap_debug.html#light-impact" title="Permalink to this headline">¶</a></h3>
<p>At this level, heap memory is additionally &#8220;poisoned&#8221; with head and tail &#8220;canary bytes&#8221; before and after each block which is allocated. If an application writes outside the bounds of the allocated buffer, the canary bytes will be corrupted and the integrity check will fail.</p>
<p>&#8220;Basic&#8221; heap corruption checks can also detect out of bounds writes, but this setting is more precise as even a single byte overrun will always be detected. With Basic heap checks, the number of overrun bytes before a failure is detected will depend on the properties of the heap.</p>
<p>Similar to other heap checks, these &#8220;canary bytes&#8221; are checked via assertion whenever memory is freed and can also be checked manually via <code class="docutils literal"><span class="pre">heap_caps_check_integrity()</span></code>.</p>
<p>This level increases memory usage, each individual allocation will use 9 to 12 additional bytes of memory (depending on alignment).</p>
</div>
<div class="section" id="comprehensive">
<h3>Comprehensive<a class="headerlink" href="heap_debug.html#comprehensive" title="Permalink to this headline">¶</a></h3>
<p>This level incorporates the &#8220;light impact&#8221; detection features plus additional checks for uninitialised-access and use-after-free bugs. In this mode, all freshly allocated memory is filled with the pattern 0xCE, and all freed memory is filled with the pattern 0xFE.</p>
<p>If an application crashes reading/writing an address related to 0xCECECECE when this setting is enabled, this indicates it has read uninitialized memory. The application should be changed to either use calloc() (which zeroes memory), or initialize the memory before using it. The value 0xCECECECE may also be seen in stack-allocated automatic variables, because in IDF most task stacks are originally allocated from the heap and in C stack memory is uninitialized by default.</p>
<p>If an application crashes reading/writing an address related to 0xFEFEFEFE, this indicates it is reading heap memory after it has been freed (a &#8220;use after free bug&#8221;.) The application should be changed to not access heap memory after it has been freed.</p>
<p>If the IDF heap allocator fails because the pattern 0xFEFEFEFE was not found in freed memory then this indicates the app has a use-after-free bug where it is writing to memory which has already been freed.</p>
<p>Enabling &#8220;Comprehensive&#8221; detection has a substantial runtime performance impact (as all memory needs to be set to the allocation patterns each time a malloc/free completes, and the memory also needs to be checked each time.)</p>
</div>
<div class="section" id="finding-heap-corruption">
<h3>Finding Heap Corruption<a class="headerlink" href="heap_debug.html#finding-heap-corruption" title="Permalink to this headline">¶</a></h3>
<p>Memory corruption can be one of the hardest classes of bugs to find and fix, as one area of memory can be corrupted from a totally different place. Some tips:</p>
<ul class="simple">
<li>Once you know the address (in memory) which is being corrupted, you can set a watchpoint on this address via JTAG to have the CPU halt when it is written to.</li>
<li>If you don&#8217;t have JTAG, but you do know roughly when the corruption happens, then you can set a watchpoint in software. A fatal exception will occur when the watchpoint triggers. For example <code class="docutils literal"><span class="pre">esp_set_watchpoint(0,</span> <span class="pre">(void</span> <span class="pre">*)addr,</span> <span class="pre">4,</span> <span class="pre">ESP_WATCHPOINT_STORE</span></code>. Note that the watchpoint is set on the current running CPU only, so if you don&#8217;t know which CPU is corrupting memory then you will need to call this function on both CPUs.</li>
<li>For buffer overflows, <a class="reference internal" href="heap_debug.html#id2">heap tracing</a> in <code class="docutils literal"><span class="pre">HEAP_TRACE_ALL</span></code> mode lets you see which callers allocate the memory address(es) immediately before the address which is being corrupted. There is a strong chance this is the code which overflows the buffer.</li>
</ul>
</div>
</div>
<div class="section" id="heap-tracing">
<span id="id2"></span><h2>Heap Tracing<a class="headerlink" href="heap_debug.html#heap-tracing" title="Permalink to this headline">¶</a></h2>
<p>Heap Tracing allows tracing of code which allocates/frees memory.</p>
<p>Note: Heap tracing &#8220;standalone&#8221; mode is currently implemented, meaning that tracing does not require any external hardware but uses internal memory to hold trace data. Heap tracing via JTAG trace port is also planned.</p>
<p>Heap tracing can perform two functions:</p>
<ul class="simple">
<li>Leak checking: find memory which is allocated and never freed.</li>
<li>Heap use analysis: show all functions that are allocating/freeing memory while the trace is running.</li>
</ul>
<div class="section" id="how-to-diagnose-memory-leaks">
<h3>How To Diagnose Memory Leaks<a class="headerlink" href="heap_debug.html#how-to-diagnose-memory-leaks" title="Permalink to this headline">¶</a></h3>
<p>If you suspect a memory leak, the first step is to figure out which part of the program is leaking memory. Use the <code class="docutils literal"><span class="pre">xPortGetFreeHeapSize()</span></code>, <code class="docutils literal"><span class="pre">heap_caps_get_free()</span></code>, and related functions to track memory use over the life of the application. Try to narrow the leak down to a single function or sequence of functions where free memory always decreases and never recovers.</p>
<p>Once you&#8217;ve identified the code which you think is leaking:</p>
<ul class="simple">
<li>Under <code class="docutils literal"><span class="pre">make</span> <span class="pre">menuconfig</span></code>, navigate to <code class="docutils literal"><span class="pre">Component</span> <span class="pre">settings</span></code> -&gt; <code class="docutils literal"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> and set <code class="docutils literal"><span class="pre">Enable</span> <span class="pre">heap</span> <span class="pre">tracing</span></code>.</li>
<li>Call the function <code class="docutils literal"><span class="pre">heap_trace_init_standalone()</span></code> early in the program, to register a buffer which can be used to record the memory trace.</li>
<li>Call the function <code class="docutils literal"><span class="pre">heap_trace_start()</span></code> to begin recording all mallocs/frees in the system. Call this immediately before the piece of code which you suspect is leaking memory.</li>
<li>Call the function <code class="docutils literal"><span class="pre">heap_trace_stop()</span></code> to stop the trace once the suspect piece of code has finished executing.</li>
<li>Call the function <code class="docutils literal"><span class="pre">heap_trace_dump()</span></code> to dump the results of the heap trace.</li>
</ul>
<p>An example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &quot;esp_heap_trace.h&quot;</span>

<span class="c1">#define NUM_RECORDS 100</span>
<span class="n">static</span> <span class="n">heap_trace_record_t</span> <span class="n">trace_record</span><span class="p">[</span><span class="n">NUM_RECORDS</span><span class="p">];</span> <span class="o">//</span> <span class="n">This</span> <span class="n">buffer</span> <span class="n">must</span> <span class="n">be</span> <span class="ow">in</span> <span class="n">internal</span> <span class="n">RAM</span>

<span class="o">...</span>

<span class="n">void</span> <span class="n">app_main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="o">...</span>
    <span class="n">ESP_ERROR_CHECK</span><span class="p">(</span> <span class="n">heap_trace_init_standalone</span><span class="p">(</span><span class="n">trace_record</span><span class="p">,</span> <span class="n">NUM_RECORDS</span><span class="p">)</span> <span class="p">);</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">some_function</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ESP_ERROR_CHECK</span><span class="p">(</span> <span class="n">heap_trace_start</span><span class="p">(</span><span class="n">HEAP_TRACE_LEAKS</span><span class="p">)</span> <span class="p">);</span>

    <span class="n">do_something_you_suspect_is_leaking</span><span class="p">();</span>

    <span class="n">ESP_ERROR_CHECK</span><span class="p">(</span> <span class="n">heap_trace_stop</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">heap_trace_dump</span><span class="p">();</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output from the heap trace will look something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="n">allocations</span> <span class="n">trace</span> <span class="p">(</span><span class="mi">100</span> <span class="n">entry</span> <span class="n">buffer</span><span class="p">)</span>
<span class="mi">32</span> <span class="nb">bytes</span> <span class="p">(</span><span class="o">@</span> <span class="mh">0x3ffaf214</span><span class="p">)</span> <span class="n">allocated</span> <span class="n">CPU</span> <span class="mi">0</span> <span class="n">ccount</span> <span class="mh">0x2e9b7384</span> <span class="n">caller</span> <span class="mh">0x400d276d</span><span class="p">:</span><span class="mh">0x400d27c1</span>
<span class="mh">0x400d276d</span><span class="p">:</span> <span class="n">leak_some_memory</span> <span class="n">at</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">idf</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">get</span><span class="o">-</span><span class="n">started</span><span class="o">/</span><span class="n">blink</span><span class="o">/</span><span class="n">main</span><span class="o">/./</span><span class="n">blink</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">27</span>

<span class="mh">0x400d27c1</span><span class="p">:</span> <span class="n">blink_task</span> <span class="n">at</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">idf</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">get</span><span class="o">-</span><span class="n">started</span><span class="o">/</span><span class="n">blink</span><span class="o">/</span><span class="n">main</span><span class="o">/./</span><span class="n">blink</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">52</span>

<span class="mi">8</span> <span class="nb">bytes</span> <span class="p">(</span><span class="o">@</span> <span class="mh">0x3ffaf804</span><span class="p">)</span> <span class="n">allocated</span> <span class="n">CPU</span> <span class="mi">0</span> <span class="n">ccount</span> <span class="mh">0x2e9b79c0</span> <span class="n">caller</span> <span class="mh">0x400d2776</span><span class="p">:</span><span class="mh">0x400d27c1</span>
<span class="mh">0x400d2776</span><span class="p">:</span> <span class="n">leak_some_memory</span> <span class="n">at</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">idf</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">get</span><span class="o">-</span><span class="n">started</span><span class="o">/</span><span class="n">blink</span><span class="o">/</span><span class="n">main</span><span class="o">/./</span><span class="n">blink</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">29</span>

<span class="mh">0x400d27c1</span><span class="p">:</span> <span class="n">blink_task</span> <span class="n">at</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">idf</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">get</span><span class="o">-</span><span class="n">started</span><span class="o">/</span><span class="n">blink</span><span class="o">/</span><span class="n">main</span><span class="o">/./</span><span class="n">blink</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">52</span>

<span class="mi">40</span> <span class="nb">bytes</span> <span class="s1">&#39;leaked&#39;</span> <span class="ow">in</span> <span class="n">trace</span> <span class="p">(</span><span class="mi">2</span> <span class="n">allocations</span><span class="p">)</span>
<span class="n">total</span> <span class="n">allocations</span> <span class="mi">2</span> <span class="n">total</span> <span class="n">frees</span> <span class="mi">0</span>
</pre></div>
</div>
<p>(Above example output is using <a class="reference internal" href="../../get-started/idf-monitor.html"><span class="doc">IDF Monitor</span></a> to automatically decode PC addresses to their source files &amp; line number.)</p>
<p>The first line indicates how many allocation entries are in the buffer, compared to its total size.</p>
<p>In <code class="docutils literal"><span class="pre">HEAP_TRACE_LEAKS</span></code> mode, for each traced memory allocation which has not already been freed a line is printed with:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">XX</span> <span class="pre">bytes</span></code> is number of bytes allocated</li>
<li><code class="docutils literal"><span class="pre">&#64;</span> <span class="pre">0x...</span></code> is the heap address returned from malloc/calloc.</li>
<li><code class="docutils literal"><span class="pre">CPU</span> <span class="pre">x</span></code> is the CPU (0 or 1) running when the allocation was made.</li>
<li><code class="docutils literal"><span class="pre">ccount</span> <span class="pre">0x...</span></code> is the CCOUNT (CPU cycle count) register value when the allocation was mode. Is different for CPU 0 vs CPU 1.</li>
<li><code class="docutils literal"><span class="pre">caller</span> <span class="pre">0x...</span></code> gives the call stack of the call to malloc()/free(), as a list of PC addresses.
These can be decoded to source files and line numbers, as shown above.</li>
</ul>
<p>The depth of the call stack recorded for each trace entry can be configured in <code class="docutils literal"><span class="pre">make</span> <span class="pre">menuconfig</span></code>, under <code class="docutils literal"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> -&gt; <code class="docutils literal"><span class="pre">Enable</span> <span class="pre">heap</span> <span class="pre">tracing</span></code> -&gt; <code class="docutils literal"><span class="pre">Heap</span> <span class="pre">tracing</span> <span class="pre">stack</span> <span class="pre">depth</span></code>. Up to 10 stack frames can be recorded for each allocation (the default is 2). Each additional stack frame increases the memory usage of each <code class="docutils literal"><span class="pre">heap_trace_record_t</span></code> record by eight bytes.</p>
<p>Finally, the total number of &#8216;leaked&#8217; bytes (bytes allocated but not freed while trace was running) is printed, and the total number of allocations this represents.</p>
<p>A warning will be printed if the trace buffer was not large enough to hold all the allocations which happened. If you see this warning, consider either shortening the tracing period or increasing the number of records in the trace buffer.</p>
</div>
<div class="section" id="performance-impact">
<h3>Performance Impact<a class="headerlink" href="heap_debug.html#performance-impact" title="Permalink to this headline">¶</a></h3>
<p>Enabling heap tracing in menuconfig increases the code size of your program, and has a very small negative impact on performance of heap allocation/free operations even when heap tracing is not running.</p>
<p>When heap tracing is running, heap allocation/free operations are substantially slower than when heap tracing is stopped. Increasing the depth of stack frames recorded for each allocation (see above) will also increase this performance impact.</p>
</div>
<div class="section" id="false-positive-memory-leaks">
<h3>False-Positive Memory Leaks<a class="headerlink" href="heap_debug.html#false-positive-memory-leaks" title="Permalink to this headline">¶</a></h3>
<p>Not everything printed by <code class="docutils literal"><span class="pre">heap_trace_dump()</span></code> is necessarily a memory leak. Among things which may show up here, but are not memory leaks:</p>
<ul class="simple">
<li>Any memory which is allocated after <code class="docutils literal"><span class="pre">heap_trace_start()</span></code> but then freed after <code class="docutils literal"><span class="pre">heap_trace_stop()</span></code> will appear in the leak dump.</li>
<li>Allocations may be made by other tasks in the system. Depending on the timing of these tasks, it&#8217;s quite possible this memory is freed after <code class="docutils literal"><span class="pre">heap_trace_stop()</span></code> is called.</li>
<li>The first time a task uses stdio - for example, when it calls printf() - a lock (RTOS mutex semaphore) is allocated by the libc. This allocation lasts until the task is deleted.</li>
<li>The Bluetooth, WiFi, and TCP/IP libraries will allocate heap memory buffers to handle incoming or outgoing data. These memory buffers are usually short lived, but some may be shown in the heap leak trace if the data was received/transmitted by the lower levels of the network while the leak trace was running.</li>
<li>TCP connections will continue to use some memory after they are closed, because of the <code class="docutils literal"><span class="pre">TIME_WAIT</span></code> state. After the <code class="docutils literal"><span class="pre">TIME_WAIT</span></code> period has completed, this memory will be freed.</li>
</ul>
<p>One way to differentiate between &#8220;real&#8221; and &#8220;false positive&#8221; memory leaks is to call the suspect code multiple times while tracing is running, and look for patterns (multiple matching allocations) in the heap trace output.</p>
</div>
</div>
<div class="section" id="api-reference-heap-tracing">
<h2>API Reference - Heap Tracing<a class="headerlink" href="heap_debug.html#api-reference-heap-tracing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>Header File<a class="headerlink" href="heap_debug.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/de750e9/components/heap/include/esp_heap_trace.h">heap/include/esp_heap_trace.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="heap_debug.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv226heap_trace_init_standaloneP19heap_trace_record_t6size_t">
<span id="heap_trace_init_standalone__heap_trace_record_tP.s"></span><span class="target" id="esp__heap__trace_8h_1a8884934797d03cc7114b64f1849420e2"></span>esp_err_t <code class="descclassname"></code><code class="descname">heap_trace_init_standalone</code><span class="sig-paren">(</span><a class="reference internal" href="heap_debug.html#_CPPv219heap_trace_record_t" title="heap_trace_record_t">heap_trace_record_t</a> *<em>record_buffer</em>, size_t <em>num_records</em><span class="sig-paren">)</span><a class="headerlink" href="heap_debug.html#_CPPv226heap_trace_init_standaloneP19heap_trace_record_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise heap tracing in standalone mode. </p>
<p>
This function must be called before any other heap tracing functions.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Standalone mode is the only mode currently supported.</dd>
</dl>
</p>
<p>To disable heap tracing and allow the buffer to be freed, stop tracing and then call heap_trace_init_standalone(NULL, 0);</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</li>
<li>ESP_ERR_INVALID_STATE Heap tracing is currently in progress.</li>
<li>ESP_OK Heap tracing initialised successfully. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">record_buffer</span></code>: Provide a buffer to use for heap trace data. Must remain valid any time heap tracing is enabled, meaning it must be allocated from internal memory not in PSRAM. </li>
<li><code class="docutils literal"><span class="pre">num_records</span></code>: Size of the heap trace buffer, as number of record structures. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216heap_trace_start17heap_trace_mode_t">
<span id="heap_trace_start__heap_trace_mode_t"></span><span class="target" id="esp__heap__trace_8h_1ac324e6c910f4a2a71e0e364130c069b6"></span>esp_err_t <code class="descclassname"></code><code class="descname">heap_trace_start</code><span class="sig-paren">(</span><a class="reference internal" href="heap_debug.html#_CPPv217heap_trace_mode_t" title="heap_trace_mode_t">heap_trace_mode_t</a> <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="heap_debug.html#_CPPv216heap_trace_start17heap_trace_mode_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start heap tracing. All heap allocations &amp; frees will be traced, until heap_trace_stop() is called. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>heap_trace_init_standalone() must be called to provide a valid buffer, before this function is called.</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this function while heap tracing is running will reset the heap trace state and continue tracing.</dd>
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</li>
<li>ESP_ERR_INVALID_STATE A non-zero-length buffer has not been set via heap_trace_init_standalone().</li>
<li>ESP_OK Tracing is started. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mode</span></code>: Mode for tracing.<ul>
<li>HEAP_TRACE_ALL means all heap allocations and frees are traced.</li>
<li>HEAP_TRACE_LEAKS means only suspected memory leaks are traced. (When memory is freed, the record is removed from the trace buffer.) </li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215heap_trace_stopv">
<span id="heap_trace_stop__void"></span><span class="target" id="esp__heap__trace_8h_1aa2a9740da05f6833efbc39c0520681de"></span>esp_err_t <code class="descclassname"></code><code class="descname">heap_trace_stop</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="heap_debug.html#_CPPv215heap_trace_stopv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stop heap tracing. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</li>
<li>ESP_ERR_INVALID_STATE Heap tracing was not in progress.</li>
<li>ESP_OK Heap tracing stopped.. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217heap_trace_resumev">
<span id="heap_trace_resume__void"></span><span class="target" id="esp__heap__trace_8h_1a62cef359ef92ecb1b0760b3e1e5e1203"></span>esp_err_t <code class="descclassname"></code><code class="descname">heap_trace_resume</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="heap_debug.html#_CPPv217heap_trace_resumev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resume heap tracing which was previously stopped. </p>
<p>Unlike heap_trace_start(), this function does not clear the buffer of any pre-existing trace records.</p>
<p>The heap trace mode is the same as when heap_trace_start() was last called (or HEAP_TRACE_ALL if heap_trace_start() was never called).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</li>
<li>ESP_ERR_INVALID_STATE Heap tracing was already started.</li>
<li>ESP_OK Heap tracing resumed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220heap_trace_get_countv">
<span id="heap_trace_get_count__void"></span><span class="target" id="esp__heap__trace_8h_1a9ac798a6e570fd665d6e5c715c1a3d1b"></span>size_t <code class="descclassname"></code><code class="descname">heap_trace_get_count</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="heap_debug.html#_CPPv220heap_trace_get_countv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return number of records in the heap trace buffer. </p>
<p>It is safe to call this function while heap tracing is running. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214heap_trace_get6size_tP19heap_trace_record_t">
<span id="heap_trace_get__s.heap_trace_record_tP"></span><span class="target" id="esp__heap__trace_8h_1a007b0b85daa123d2a7a7d74e6383f42c"></span>esp_err_t <code class="descclassname"></code><code class="descname">heap_trace_get</code><span class="sig-paren">(</span>size_t <em>index</em>, <a class="reference internal" href="heap_debug.html#_CPPv219heap_trace_record_t" title="heap_trace_record_t">heap_trace_record_t</a> *<em>record</em><span class="sig-paren">)</span><a class="headerlink" href="heap_debug.html#_CPPv214heap_trace_get6size_tP19heap_trace_record_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a raw record from the heap trace buffer. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>It is safe to call this function while heap tracing is running, however in HEAP_TRACE_LEAK mode record indexing may skip entries unless heap tracing is stopped first.</dd>
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</li>
<li>ESP_ERR_INVALID_STATE Heap tracing was not initialised.</li>
<li>ESP_ERR_INVALID_ARG Index is out of bounds for current heap trace record count.</li>
<li>ESP_OK Record returned successfully. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">index</span></code>: Index (zero-based) of the record to return. </li>
<li><code class="docutils literal"><span class="pre">record</span></code>: Record where the heap trace record will be copied. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215heap_trace_dumpv">
<span id="heap_trace_dump__void"></span><span class="target" id="esp__heap__trace_8h_1a9e80331ce5188a84bb60fdf0bd1ab828"></span>void <code class="descclassname"></code><code class="descname">heap_trace_dump</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="heap_debug.html#_CPPv215heap_trace_dumpv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dump heap trace record data to stdout. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>It is safe to call this function while heap tracing is running, however in HEAP_TRACE_LEAK mode the dump may skip entries unless heap tracing is stopped first. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="structures">
<h3>Structures<a class="headerlink" href="heap_debug.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv219heap_trace_record_t">
<span id="heap_trace_record_t"></span><span class="target" id="structheap__trace__record__t"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">heap_trace_record_t</code><a class="headerlink" href="heap_debug.html#_CPPv219heap_trace_record_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trace record data type. Stores information about an allocated region of memory. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv2N19heap_trace_record_t6ccountE">
<span id="heap_trace_record_t::ccount__uint32_t"></span><span class="target" id="structheap__trace__record__t_1a3a5a11507218cbab8b0f1ec08f8f5c40"></span>uint32_t <code class="descname">ccount</code><a class="headerlink" href="heap_debug.html#_CPPv2N19heap_trace_record_t6ccountE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CCOUNT of the CPU when the allocation was made. LSB (bit value 1) is the CPU number (0 or 1). */. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N19heap_trace_record_t7addressE">
<span id="heap_trace_record_t::address__voidP"></span><span class="target" id="structheap__trace__record__t_1a948933cb24b2aa572f45b806e82ae818"></span>void *<code class="descname">address</code><a class="headerlink" href="heap_debug.html#_CPPv2N19heap_trace_record_t7addressE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Address which was allocated. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N19heap_trace_record_t4sizeE">
<span id="heap_trace_record_t::size__s"></span><span class="target" id="structheap__trace__record__t_1a1a13eb467724bf28ccacb694627b6f3d"></span>size_t <code class="descname">size</code><a class="headerlink" href="heap_debug.html#_CPPv2N19heap_trace_record_t4sizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Size of the allocation. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N19heap_trace_record_t10alloced_byE">
<span id="heap_trace_record_t::alloced_by__voidPA"></span><span class="target" id="structheap__trace__record__t_1aa3ed0367bc373515a3d4961a7269fdf2"></span>void *<code class="descname">alloced_by</code>[CONFIG_HEAP_TRACING_STACK_DEPTH]<a class="headerlink" href="heap_debug.html#_CPPv2N19heap_trace_record_t10alloced_byE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Call stack of the caller which allocated the memory. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N19heap_trace_record_t8freed_byE">
<span id="heap_trace_record_t::freed_by__voidPA"></span><span class="target" id="structheap__trace__record__t_1a3ad6d8c9eb49b5285a508e1ec230cea1"></span>void *<code class="descname">freed_by</code>[CONFIG_HEAP_TRACING_STACK_DEPTH]<a class="headerlink" href="heap_debug.html#_CPPv2N19heap_trace_record_t8freed_byE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Call stack of the caller which freed the memory (all zero if not freed.) </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="macros">
<h3>Macros<a class="headerlink" href="heap_debug.html#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.CONFIG_HEAP_TRACING_STACK_DEPTH">
<span class="target" id="esp__heap__trace_8h_1a962faaf6cd044ada51170a779dd716ff"></span><code class="descname">CONFIG_HEAP_TRACING_STACK_DEPTH</code><a class="headerlink" href="heap_debug.html#c.CONFIG_HEAP_TRACING_STACK_DEPTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="enumerations">
<h3>Enumerations<a class="headerlink" href="heap_debug.html#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv217heap_trace_mode_t">
<span id="heap_trace_mode_t"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563d"></span><em class="property">enum </em><code class="descclassname"></code><code class="descname">heap_trace_mode_t</code><a class="headerlink" href="heap_debug.html#_CPPv217heap_trace_mode_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="member">
<dt id="_CPPv214HEAP_TRACE_ALL">
<span id="HEAP_TRACE_ALL"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563da852d11079e290f8415591926a5465d0e"></span><code class="descname">HEAP_TRACE_ALL</code><a class="headerlink" href="heap_debug.html#_CPPv214HEAP_TRACE_ALL" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv216HEAP_TRACE_LEAKS">
<span id="HEAP_TRACE_LEAKS"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563da8b871cc1175288956caf38a820f56930"></span><code class="descname">HEAP_TRACE_LEAKS</code><a class="headerlink" href="heap_debug.html#_CPPv216HEAP_TRACE_LEAKS" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="intr_alloc.html" class="btn btn-neutral float-right" title="Interrupt allocation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mem_alloc.html" class="btn btn-neutral" title="Heap Memory Allocation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016 - 2017, Espressif.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'v3.0-dev-806-gde750e9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>