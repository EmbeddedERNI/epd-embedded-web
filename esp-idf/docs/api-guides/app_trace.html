

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Application Level Tracing library &mdash; ESP-IDF Programming Guide v3.0-dev-806-gde750e9 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="author" title="About these documents"
              href="../about.html"/>
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="ESP-IDF Programming Guide v3.0-dev-806-gde750e9 documentation" href="../index.html"/>
        <link rel="up" title="JTAG Debugging" href="jtag-debugging/index.html"/>
        <link rel="next" title="Partition Tables" href="partition-tables.html"/>
        <link rel="prev" title="Tips and Quirks" href="jtag-debugging/tips-and-quirks.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ESP-IDF Programming Guide
          

          
          </a>

          
            
            
              <div class="version">
                v3.0-dev-806-gde750e9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../get-started/index.html">Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw-reference/index.html">H/W Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="general-notes.html">General Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system.html">Build System</a></li>
<li class="toctree-l2"><a class="reference internal" href="deep-sleep-stub.html">Deep Sleep Wake Stubs</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_dump.html">ESP32 Core Dump</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/flash-encryption.html">Flash Encryption</a></li>
<li class="toctree-l2"><a class="reference internal" href="freertos-smp.html">FreeRTOS SMP Changes</a></li>
<li class="toctree-l2"><a class="reference internal" href="hlinterrupts.html">High Level Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="jtag-debugging/index.html">JTAG Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition-tables.html">Partition Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/secure-boot.html">Secure Boot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ulp.html">ULP Coprocessor</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests.html">Unit Testing</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="app_trace.html#">Application Level Tracing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html#modes-of-operation">Modes of Operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html#configuration-options-and-dependencies">Configuration Options and Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html#how-to-use-this-library">How to use this library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="app_trace.html#application-specific-tracing">Application Specific Tracing</a></li>
<li class="toctree-l4"><a class="reference internal" href="app_trace.html#logging-to-host">Logging to Host</a></li>
<li class="toctree-l4"><a class="reference internal" href="app_trace.html#system-behaviour-analysis-with-segger-systemview">System Behaviour Analysis with SEGGER SystemView</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="romconsole.html">ROM debug console</a></li>
<li class="toctree-l2"><a class="reference internal" href="wifi.html">WiFi Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="external-ram.html">External SPI-connected RAM</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../COPYRIGHT.html">Copyrights</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ESP-IDF Programming Guide</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">API Guides</a> &raquo;</li>
        
          <li><a href="jtag-debugging/index.html">JTAG Debugging</a> &raquo;</li>
        
      <li>Application Level Tracing library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-guides/app_trace.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="application-level-tracing-library">
<h1>Application Level Tracing library<a class="headerlink" href="app_trace.html#application-level-tracing-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="app_trace.html#overview" title="Permalink to this headline">¶</a></h2>
<p>IDF provides useful feature for program behaviour analysis: application level tracing. It is implemented in the corresponding library and can be enabled in menuconfig. This feature allows to transfer arbitrary data between host and ESP32 via JTAG interface with small overhead on program execution.</p>
<p>Developers can use this library to send application specific state of execution to the host and receive commands or other type of info in the opposite direction at runtime. The main use cases of this library are:</p>
<ol class="arabic simple">
<li>Collecting application specific data. See <a class="reference internal" href="app_trace.html#application-specific-tracing">Application Specific Tracing</a>.</li>
<li>Lightweight logging to the host. See <a class="reference internal" href="app_trace.html#logging-to-host">Logging to Host</a>.</li>
<li>System behaviour analysis. See <a class="reference internal" href="app_trace.html#system-behaviour-analysis-with-segger-systemview">System Behaviour Analysis with SEGGER SystemView</a>.</li>
</ol>
<p>Tracing components when working over JTAG interface are shown in the figure below.</p>
<div class="align-center figure" id="id2">
<img alt="Tracing Components when Working Over JTAG" src="../_images/app_trace-overview.jpg" />
<p class="caption"><span class="caption-text">Tracing Components when Working Over JTAG</span></p>
</div>
</div>
<div class="section" id="modes-of-operation">
<h2>Modes of Operation<a class="headerlink" href="app_trace.html#modes-of-operation" title="Permalink to this headline">¶</a></h2>
<p>The library supports two modes of operation:</p>
<p><strong>Post-mortem mode</strong>. This is the default mode. The mode does not need interaction from the host side. In this mode tracing module does not check whether host has read all the data from <em>HW UP BUFFER</em> buffer and overwrites old data with the new ones. This mode is useful when only the latest trace data are interesting to the user, e.g. for analyzing program&#8217;s behaviour just before the crash. Host can read the data later on upon user request, e.g. via special OpenOCD command in case of working via JTAG interface.</p>
<p><strong>Streaming mode.</strong> Tracing module enters this mode when host connects to ESP32. In this mode before writing new data to <em>HW UP BUFFER</em> tracing module checks that there is enough space in it and if necessary waits for the host to read data and free enough memory. Maximum waiting time is controled via timeout values passed by users to corresponding API routines. So when application tries to write data to trace buffer using finite value of the maximum waiting time it is possible situation that this data will be dropped. Especially this is true for tracing from time critical code (ISRs, OS scheduler code etc.) when infinite timeouts can lead to system malfunction. In order to avoid loss of such critical data developers can enable additional data buffering via menuconfig option <a class="reference internal" href="../api-reference/kconfig.html#config-esp32-apptrace-pending-data-size-max"><span class="std std-ref">ESP32_APPTRACE_PENDING_DATA_SIZE_MAX</span></a>. This macro specifies the size of data which can be buffered in above conditions. The option can also help to overcome situation when data transfer to the host is temporarily slowed down, e.g due to USB bus congestions etc. But it will not help when average bitrate of trace data stream exceeds HW interface capabilities.</p>
</div>
<div class="section" id="configuration-options-and-dependencies">
<h2>Configuration Options and Dependencies<a class="headerlink" href="app_trace.html#configuration-options-and-dependencies" title="Permalink to this headline">¶</a></h2>
<p>Using of this feature depends on two components:</p>
<ol class="arabic simple">
<li><strong>Host side:</strong> Application tracing is done over JTAG, so it needs OpenOCD to be set up and running on host machine. For instructions how to set it up, please, see <a class="reference internal" href="jtag-debugging/index.html"><span class="doc">JTAG Debugging</span></a> for details.</li>
<li><strong>Target side:</strong> Application tracing functionality can be enabled in menuconfig. <em>Component config &gt; Application Level Tracing</em> menu allows selecting destination for the trace data (HW interface for transport). Choosing any of the destinations automatically enables <code class="docutils literal"><span class="pre">CONFIG_ESP32_APPTRACE_ENABLE</span></code> option.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to achieve higher data rates and minimize number of dropped packets it is recommended to optimize setting of JTAG clock frequency, so it is at maximum and still provides stable operation of JTAG, see <a class="reference internal" href="jtag-debugging/tips-and-quirks.html#jtag-debugging-tip-optimize-jtag-speed"><span class="std std-ref">Optimize JTAG speed</span></a>.</p>
</div>
<p>There are two additional menuconfig options not mentioned above:</p>
<ol class="arabic simple">
<li><em>Threshold for flushing last trace data to host on panic</em> (<a class="reference internal" href="../api-reference/kconfig.html#config-esp32-apptrace-postmortem-flush-trax-thresh"><span class="std std-ref">ESP32_APPTRACE_POSTMORTEM_FLUSH_TRAX_THRESH</span></a>). This option is necessary due to the nature of working over JTAG. In that mode trace data are exposed to the host in 16KB blocks. In post-mortem mode when one block is filled it is exposed to the host and the previous one becomes unavailable. In other words trace data are overwritten in 16KB granularity. On panic the latest data from the current input block are exposed to host and host can read them for post-analysis. It can happen that system panic occurs when there are very small amount of data which are not exposed to the host yet. In this case the previous 16KB of collected data will be lost and host will see the latest, but very small piece of the trace. It can be insufficient to diagnose the problem. This menuconfig option allows avoiding such situations. It controls the threshold for flushing data in case of panic. For example user can decide that it needs not less then 512 bytes of the recent trace data, so if there is less then 512 bytes of pending data at the moment of panic they will not be flushed and will not overwrite previous 16KB. The option is only meaningful in post-mortem mode and when working over JTAG.</li>
<li><em>Timeout for flushing last trace data to host on panic</em> (<a class="reference internal" href="../api-reference/kconfig.html#config-esp32-apptrace-onpanic-host-flush-tmo"><span class="std std-ref">ESP32_APPTRACE_ONPANIC_HOST_FLUSH_TMO</span></a>). The option is only meaningful in streaming mode and controls the maximum time tracing module will wait for the host to read the last data in case of panic.</li>
</ol>
</div>
<div class="section" id="how-to-use-this-library">
<h2>How to use this library<a class="headerlink" href="app_trace.html#how-to-use-this-library" title="Permalink to this headline">¶</a></h2>
<p>This library provides API for transferring arbitrary data between host and ESP32. When enabled in menuconfig target application tracing module is initialized automatically at the system startup, so all what the user needs to do is to call corresponding API to send, receive or flush the data.</p>
<div class="section" id="application-specific-tracing">
<h3>Application Specific Tracing<a class="headerlink" href="app_trace.html#application-specific-tracing" title="Permalink to this headline">¶</a></h3>
<p>In general user should decide what type of data should be transferred in every direction and how these data must be interpreted (processed). The following steps must be performed to transfer data between target and host:</p>
<ol class="arabic">
<li><p class="first">On target side user should implement algorithms for writing trace data to the host. Piece of code below shows an example how to do this.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;esp_app_trace.h&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello World!&quot;</span><span class="p">;</span>
<span class="n">esp_err_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">esp_apptrace_write</span><span class="p">(</span><span class="n">ESP_APPTRACE_DEST_TRAX</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">ESP_APPTRACE_TMO_INFINITE</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">ESP_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ESP_LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&quot;Failed to write data to host!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">esp_apptrace_write()</span></code> function uses memcpy to copy user data to the internal buffer. In some cases it can be more optimal to use <code class="docutils literal"><span class="pre">esp_apptrace_buffer_get()</span></code> and <code class="docutils literal"><span class="pre">esp_apptrace_buffer_put()</span></code> functions. They allow developers to allocate buffer and fill it themselves. The following piece of code shows how to do this.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;esp_app_trace.h&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">esp_apptrace_buffer_get</span><span class="p">(</span><span class="n">ESP_APPTRACE_DEST_TRAX</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">100</span><span class="cm">/*tmo in us*/</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ESP_LOGE</span><span class="p">(</span><span class="s">&quot;Failed to get buffer!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ESP_FAIL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;Here is the number %d&quot;</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
<span class="n">esp_err_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">esp_apptrace_buffer_put</span><span class="p">(</span><span class="n">ESP_APPTRACE_DEST_TRAX</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">100</span><span class="cm">/*tmo in us*/</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">ESP_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* in case of error host tracing tool (e.g. OpenOCD) will report incomplete user buffer */</span>
    <span class="n">ESP_LOGE</span><span class="p">(</span><span class="s">&quot;Failed to put buffer!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Also according to his needs user may want to receive data from the host. Piece of code below shows an example how to do this.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;esp_app_trace.h&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">down_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/* config down buffer */</span>
<span class="n">esp_apptrace_down_buffer_config</span><span class="p">(</span><span class="n">down_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">down_buf</span><span class="p">));</span>
<span class="cm">/* check for incoming data and read them if any */</span>
<span class="n">esp_err_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">esp_apptrace_read</span><span class="p">(</span><span class="n">ESP_APPTRACE_DEST_TRAX</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sz</span><span class="p">,</span> <span class="mi">0</span><span class="cm">/*do not wait*/</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">ESP_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ESP_LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&quot;Failed to read data from host!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* we have data, process them */</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">esp_apptrace_read()</span></code> function uses memcpy to copy host data to user buffer. In some cases it can be more optimal to use <code class="docutils literal"><span class="pre">esp_apptrace_down_buffer_get()</span></code> and <code class="docutils literal"><span class="pre">esp_apptrace_down_buffer_put()</span></code> functions. They allow developers to occupy chunk of read buffer and process it in-place. The following piece of code shows how to do this.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;esp_app_trace.h&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="kt">char</span> <span class="n">down_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">number</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

<span class="cm">/* config down buffer */</span>
<span class="n">esp_apptrace_down_buffer_config</span><span class="p">(</span><span class="n">down_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">down_buf</span><span class="p">));</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">esp_apptrace_down_buffer_get</span><span class="p">(</span><span class="n">ESP_APPTRACE_DEST_TRAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sz</span><span class="p">,</span> <span class="mi">100</span><span class="cm">/*tmo in us*/</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ESP_LOGE</span><span class="p">(</span><span class="s">&quot;Failed to get buffer!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ESP_FAIL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">number</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Here is the number %d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">number</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;No data&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">esp_err_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">esp_apptrace_down_buffer_put</span><span class="p">(</span><span class="n">ESP_APPTRACE_DEST_TRAX</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">100</span><span class="cm">/*tmo in us*/</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">ESP_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* in case of error host tracing tool (e.g. OpenOCD) will report incomplete user buffer */</span>
    <span class="n">ESP_LOGE</span><span class="p">(</span><span class="s">&quot;Failed to put buffer!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">The next step is to build the program image and download it to the target as described in <a class="reference internal" href="../get-started/make-project.html"><span class="doc">Build and Flash</span></a>.</p>
</li>
<li><p class="first">Run OpenOCD (see <a class="reference internal" href="jtag-debugging/index.html"><span class="doc">JTAG Debugging</span></a>).</p>
</li>
<li><p class="first">Connect to OpenOCD telnet server. It can be done using the following command in terminal <code class="docutils literal"><span class="pre">telnet</span> <span class="pre">&lt;oocd_host&gt;</span> <span class="pre">4444</span></code>. If telnet session is opened on the same machine which runs OpenOCD you can use <code class="docutils literal"><span class="pre">localhost</span></code> as <code class="docutils literal"><span class="pre">&lt;oocd_host&gt;</span></code> in the command above.</p>
</li>
<li><p class="first">Start trace data collection using special OpenOCD command. This command will transfer tracing data and redirect them to specified file or socket (currently only files are supported as trace data destination). For description of the corresponding commands see <a class="reference internal" href="app_trace.html#openocd-application-level-tracing-commands">OpenOCD Application Level Tracing Commands</a>.</p>
</li>
<li><p class="first">The final step is to process received data. Since format of data is defined by user the processing stage is out of the scope of this document. Good starting points for data processor are python scripts in <code class="docutils literal"><span class="pre">$IDF_PATH/tools/esp_app_trace</span></code>: <code class="docutils literal"><span class="pre">apptrace_proc.py</span></code> (used for feature tests) and <code class="docutils literal"><span class="pre">logtrace_proc.py</span></code> (see more details in section <a class="reference internal" href="app_trace.html#logging-to-host">Logging to Host</a>).</p>
</li>
</ol>
<div class="section" id="openocd-application-level-tracing-commands">
<h4>OpenOCD Application Level Tracing Commands<a class="headerlink" href="app_trace.html#openocd-application-level-tracing-commands" title="Permalink to this headline">¶</a></h4>
<p><em>HW UP BUFFER</em> is shared between user data blocks and filling of the allocated memory is performed on behalf of the API caller (in task or ISR context). In multithreading environment it can happen that task/ISR which fills the buffer is preempted by another high priority task/ISR. So it is possible situation that user data preparation process is not completed at the moment when that chunk is read by the host. To handle such conditions tracing module prepends all user data chunks with header which contains allocated user buffer size (2 bytes) and length of actually written data (2 bytes). So total length of the header is 4 bytes. OpenOCD command which reads trace data reports error when it reads incomplete user data chunk, but in any case it puts contents of the whole user chunk (including unfilled area) to output file.</p>
<p>Below is the description of available OpenOCD application tracing commands.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently OpenOCD does not provide commands to send arbitrary user data to the target.</p>
</div>
<p>Command usage:</p>
<p><code class="docutils literal"><span class="pre">esp32</span> <span class="pre">apptrace</span> <span class="pre">[start</span> <span class="pre">&lt;options&gt;]</span> <span class="pre">|</span> <span class="pre">[stop]</span> <span class="pre">|</span> <span class="pre">[status]</span> <span class="pre">|</span> <span class="pre">[dump</span> <span class="pre">&lt;cores_num&gt;</span> <span class="pre">&lt;outfile&gt;]</span></code></p>
<p>Sub-commands:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">start</span></code></dt>
<dd>Start tracing (continuous streaming).</dd>
<dt><code class="docutils literal"><span class="pre">stop</span></code></dt>
<dd>Stop tracing.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Get tracing status.</dd>
<dt><code class="docutils literal"><span class="pre">dump</span></code></dt>
<dd>Dump all data from  (post-mortem dump).</dd>
</dl>
<p>Start command syntax:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">start</span> <span class="pre">&lt;outfile&gt;</span> <span class="pre">[poll_period</span> <span class="pre">[trace_size</span> <span class="pre">[stop_tmo</span> <span class="pre">[wait4halt</span> <span class="pre">[skip_size]]]]</span></code></div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">outfile</span></code></dt>
<dd>Path to file to save data from both CPUs. This argument should have the following format: <code class="docutils literal"><span class="pre">file://path/to/file</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">poll_period</span></code></dt>
<dd>Data polling period (in ms) for available trace data. If greater then 0 then command runs in non-blocking mode. By default 1 ms.</dd>
<dt><code class="docutils literal"><span class="pre">trace_size</span></code></dt>
<dd>Maximum size of data to collect (in bytes). Tracing is stopped after specified amount of data is received. By default -1 (trace size stop trigger is disabled).</dd>
<dt><code class="docutils literal"><span class="pre">stop_tmo</span></code></dt>
<dd>Idle timeout (in sec). Tracing is stopped if there is no data for specified period of time. By default -1 (disable this stop trigger). Optionally set it to value longer than longest pause between tracing commands from target.</dd>
<dt><code class="docutils literal"><span class="pre">wait4halt</span></code></dt>
<dd>If 0 start tracing immediately, otherwise command waits for the target to be halted (after reset, by breakpoint etc.) and then automatically resumes it and starts tracing. By default 0.</dd>
<dt><code class="docutils literal"><span class="pre">skip_size</span></code></dt>
<dd>Number of bytes to skip at the start. By default 0.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">poll_period</span></code> is 0, OpenOCD telnet command line will not be available until tracing is stopped. You must stop it manually by resetting the board or pressing Ctrl+C in OpenOCD window (not one with the telnet session). Another option is to set <code class="docutils literal"><span class="pre">trace_size</span></code> and wait until this size of data is collected. At this point tracing stops automatically.</p>
</div>
<p>Command usage examples:</p>
<ol class="arabic">
<li><p class="first">Collect 2048 bytes of tracing data to a file &#8220;trace.log&#8221;. The file will be saved in &#8220;openocd-esp32&#8221; directory.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>esp32 apptrace start file://trace.log 1 2048 5 0 0
</pre></div>
</div>
<p>The tracing data will be retrieved and saved in non-blocking mode. This process will stop automatically after 2048 bytes are collected, or if no data are available for more than 5 seconds.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Tracing data is buffered before it is made available to OpenOCD. If you see &#8220;Data timeout!&#8221; message, then the target is likely sending not enough data to empty the buffer to OpenOCD before expiration of timeout. Either increase the timeout or use a function <code class="docutils literal"><span class="pre">esp_apptrace_flush()</span></code> to flush the data on specific intervals.</p>
</div>
</li>
<li><p class="first">Retrieve tracing data indefinitely in non-blocking mode.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>esp32 apptrace start file://trace.log 1 -1 -1 0 0
</pre></div>
</div>
<p>There is no limitation on the size of collected data and there is no any data timeout set. This process may be stopped by issuing <code class="docutils literal"><span class="pre">esp32</span> <span class="pre">apptrace</span> <span class="pre">stop</span></code> command on OpenOCD telnet prompt, or by pressing Ctrl+C in OpenOCD window.</p>
</li>
<li><p class="first">Retrieve tracing data and save them indefinitely.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>esp32 apptrace start file://trace.log 0 -1 -1 0 0
</pre></div>
</div>
<p>OpenOCD telnet command line prompt will not be available until tracing is stopped. To stop tracing press Ctrl+C in OpenOCD window.</p>
</li>
<li><p class="first">Wait for target to be halted. Then resume target&#8217;s operation and start data retrieval. Stop after collecting 2048 bytes of data:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>esp32 apptrace start file://trace.log 0 2048 -1 1 0
</pre></div>
</div>
<p>There is an option to configure target to halt after reset on start of scheduler. To do so, go to menuconfig and enable option <em>Stop program on scheduler start when JTAG/OCD is detected</em> under <em>Component config &gt; FreeRTOS</em>.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="logging-to-host">
<span id="app-trace-logging-to-host"></span><h3>Logging to Host<a class="headerlink" href="app_trace.html#logging-to-host" title="Permalink to this headline">¶</a></h3>
<p>IDF implements useful feature: logging to host via application level tracing library. This is a kind of semihosting when all ESP_LOGx calls sends strings to be printed to the host instead of UART. This can be useful because &#8220;printing to host&#8221; eliminates some steps performed when logging to UART. The most part of work is done on the host.</p>
<p>By default IDF&#8217;s logging library uses vprintf-like function to write formatted output to dedicated UART. In general it involves the following steps:</p>
<ol class="arabic simple">
<li>Format string is parsed to obtain type of each argument.</li>
<li>According to its type every argument is converted to string representation.</li>
<li>Format string combined with converted arguments is sent to UART.</li>
</ol>
<p>Though implementation of vprintf-like function can be optimised to a certain level, all steps above have to be performed in any case and every step takes some time (especially item 3). So it is frequent situation when addition of extra logging to the program to diagnose some problem changes its behaviour and problem disappears or in the worst cases program can not work normally at all and ends up with an error or even hangs.</p>
<p>Possible ways to overcome this problem are to use higher UART bitrates (or another faster interface) and/or move string formatting procedure to the host.</p>
<p>Application level tracing feature can be used to transfer log information to host using <code class="docutils literal"><span class="pre">esp_apptrace_vprintf</span></code> function. This function does not perform full parsing of the format string and arguments, instead it just calculates number of arguments passed and sends them along with the format string address to the host. On the host log data are processed and printed out by a special Python script.</p>
<div class="section" id="limitations">
<h4>Limitations<a class="headerlink" href="app_trace.html#limitations" title="Permalink to this headline">¶</a></h4>
<p>Current implementation of logging over JTAG has some limitations:</p>
<ol class="arabic simple">
<li>Tracing from <code class="docutils literal"><span class="pre">ESP_EARLY_LOGx</span></code> macros is not supported.</li>
<li>No support for printf arguments which size exceeds 4 bytes (e.g. <code class="docutils literal"><span class="pre">double</span></code> and <code class="docutils literal"><span class="pre">uint64_t</span></code>).</li>
<li>Only strings from .rodata section are supported as format strings and arguments.</li>
<li>Maximum number of printf arguments is 256.</li>
</ol>
</div>
<div class="section" id="how-to-use-it">
<h4>How To Use It<a class="headerlink" href="app_trace.html#how-to-use-it" title="Permalink to this headline">¶</a></h4>
<p>In order to use logging via trace module user needs to perform the following steps:</p>
<ol class="arabic simple">
<li>On target side special vprintf-like function needs to be installed. As it was mentioned earlier this function is <code class="docutils literal"><span class="pre">esp_apptrace_vprintf</span></code>. It sends log data to the host. Example code is provided in <a class="reference external" href="https://github.com/espressif/esp-idf/tree/de750e9/examples/system/app_trace_to_host">system/app_trace_to_host</a>.</li>
<li>Follow instructions in items 2-5 in <a class="reference internal" href="app_trace.html#application-specific-tracing">Application Specific Tracing</a>.</li>
<li>To print out collected log records, run the following command in terminal: <code class="docutils literal"><span class="pre">$IDF_PATH/tools/esp_app_trace/logtrace_proc.py</span> <span class="pre">/path/to/trace/file</span> <span class="pre">/path/to/program/elf/file</span></code>.</li>
</ol>
<div class="section" id="log-trace-processor-command-options">
<h5>Log Trace Processor Command Options<a class="headerlink" href="app_trace.html#log-trace-processor-command-options" title="Permalink to this headline">¶</a></h5>
<p>Command usage:</p>
<p><code class="docutils literal"><span class="pre">logtrace_proc.py</span> <span class="pre">[-h]</span> <span class="pre">[--no-errors]</span> <span class="pre">&lt;trace_file&gt;</span> <span class="pre">&lt;elf_file&gt;</span></code></p>
<p>Positional arguments:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">trace_file</span></code></dt>
<dd>Path to log trace file</dd>
<dt><code class="docutils literal"><span class="pre">elf_file</span></code></dt>
<dd>Path to program ELF file</dd>
</dl>
<p>Optional arguments:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">-h</span></code>, <code class="docutils literal"><span class="pre">--help</span></code></dt>
<dd>show this help message and exit</dd>
<dt><code class="docutils literal"><span class="pre">--no-errors</span></code>, <code class="docutils literal"><span class="pre">-n</span></code></dt>
<dd>Do not print errors</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="system-behaviour-analysis-with-segger-systemview">
<h3>System Behaviour Analysis with SEGGER SystemView<a class="headerlink" href="app_trace.html#system-behaviour-analysis-with-segger-systemview" title="Permalink to this headline">¶</a></h3>
<p>Another useful IDF feature built on top of application tracing library is the system level tracing which produces traces compatible with SEGGER SystemView tool (see <a class="reference external" href="https://www.segger.com/products/development-tools/systemview/">SystemView</a>). SEGGER SystemView is a real-time recording and visualization tool that allows to analyze runtime behavior of an application.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently IDF-based application is able to generate SystemView compatible traces in form of files to be opened in SystemView application. The tracing process can not yet be controlled using that tool.</p>
</div>
<div class="section" id="id1">
<h4>How To Use It<a class="headerlink" href="app_trace.html#id1" title="Permalink to this headline">¶</a></h4>
<p>Support for this feature is enabled by <em>Component config &gt; Application Level Tracing &gt; FreeRTOS SystemView Tracing</em> (<a class="reference internal" href="../api-reference/kconfig.html#config-sysview-enable"><span class="std std-ref">SYSVIEW_ENABLE</span></a>) menuconfig option. There are several other options enabled under the same menu:</p>
<ol class="arabic">
<li><p class="first"><em>ESP32 timer to use as SystemView timestamp source</em> (<a class="reference internal" href="../api-reference/kconfig.html#config-sysview-ts-source"><span class="std std-ref">SYSVIEW_TS_SOURCE</span></a>) selects the source of timestamps for SystemView events. In single core mode timestamps are generated using ESP32 internal cycle counter running at maximum 240 Mhz (~4 ns granularity). In dual-core mode external timer working at 40Mhz is used, so timestamp granularity is 25 ns.</p>
</li>
<li><p class="first">Individually enabled or disabled collection of SystemView events (<code class="docutils literal"><span class="pre">CONFIG_SYSVIEW_EVT_XXX</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li>Trace Buffer Overflow Event</li>
<li>ISR Enter Event</li>
<li>ISR Exit Event</li>
<li>ISR Exit to Scheduler Event</li>
<li>Task Start Execution Event</li>
<li>Task Stop Execution Event</li>
<li>Task Start Ready State Event</li>
<li>Task Stop Ready State Event</li>
<li>Task Create Event</li>
<li>Task Terminate Event</li>
<li>System Idle Event</li>
<li>Timer Enter Event</li>
<li>Timer Exit Event</li>
</ul>
</div></blockquote>
</li>
</ol>
<p>IDF has all the code required to produce SystemView compatible traces, so user can just configure necessary project options (see above), build, download the image to target and use OpenOCD to collect data as described in the previous sections.</p>
</div>
<div class="section" id="openocd-systemview-tracing-command-options">
<h4>OpenOCD SystemView Tracing Command Options<a class="headerlink" href="app_trace.html#openocd-systemview-tracing-command-options" title="Permalink to this headline">¶</a></h4>
<p>Command usage:</p>
<p><code class="docutils literal"><span class="pre">esp32</span> <span class="pre">sysview</span> <span class="pre">[start</span> <span class="pre">&lt;options&gt;]</span> <span class="pre">|</span> <span class="pre">[stop]</span> <span class="pre">|</span> <span class="pre">[status]</span></code></p>
<p>Sub-commands:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">start</span></code></dt>
<dd>Start tracing (continuous streaming).</dd>
<dt><code class="docutils literal"><span class="pre">stop</span></code></dt>
<dd>Stop tracing.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Get tracing status.</dd>
</dl>
<p>Start command syntax:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">start</span> <span class="pre">&lt;outfile1&gt;</span> <span class="pre">[outfile2]</span> <span class="pre">[poll_period</span> <span class="pre">[trace_size</span> <span class="pre">[stop_tmo]]]</span></code></div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">outfile1</span></code></dt>
<dd>Path to file to save data from PRO CPU. This argument should have the following format: <code class="docutils literal"><span class="pre">file://path/to/file</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">outfile2</span></code></dt>
<dd>Path to file to save data from APP CPU. This argument should have the following format: <code class="docutils literal"><span class="pre">file://path/to/file</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">poll_period</span></code></dt>
<dd>Data polling period (in ms) for available trace data. If greater then 0 then command runs in non-blocking mode. By default 1 ms.</dd>
<dt><code class="docutils literal"><span class="pre">trace_size</span></code></dt>
<dd>Maximum size of data to collect (in bytes). Tracing is stopped after specified amount of data is received. By default -1 (trace size stop trigger is disabled).</dd>
<dt><code class="docutils literal"><span class="pre">stop_tmo</span></code></dt>
<dd>Idle timeout (in sec). Tracing is stopped if there is no data for specified period of time. By default -1 (disable this stop trigger).</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">poll_period</span></code> is 0 OpenOCD telnet command line will not be available until tracing is stopped. You must stop it manually by resetting the board or pressing Ctrl+C in OpenOCD window (not one with the telnet session). Another option is to set <code class="docutils literal"><span class="pre">trace_size</span></code> and wait until this size of data is collected. At this point tracing stops automatically.</p>
</div>
<p>Command usage examples:</p>
<ol class="arabic">
<li><p class="first">Collect SystemView tracing data to files &#8220;pro-cpu.SVDat&#8221; and &#8220;pro-cpu.SVDat&#8221;. The files will be saved in &#8220;openocd-esp32&#8221; directory.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>esp32 sysview start file://pro-cpu.SVDat file://app-cpu.SVDat
</pre></div>
</div>
<p>The tracing data will be retrieved and saved in non-blocking mode. To stop data this process enter <code class="docutils literal"><span class="pre">esp32</span> <span class="pre">apptrace</span> <span class="pre">stop</span></code> command on OpenOCD telnet prompt, Optionally pressing Ctrl+C in OpenOCD window.</p>
</li>
<li><p class="first">Retrieve tracing data and save them indefinitely.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>esp32 sysview start file://pro-cpu.SVDat file://app-cpu.SVDat 0 -1 -1
</pre></div>
</div>
<p>OpenOCD telnet command line prompt will not be available until tracing is stopped. To stop tracing, press Ctrl+C in OpenOCD window.</p>
</li>
</ol>
</div>
<div class="section" id="data-visualization">
<h4>Data Visualization<a class="headerlink" href="app_trace.html#data-visualization" title="Permalink to this headline">¶</a></h4>
<p>After trace data are collected user can use special tool to visualize the results and inspect behaviour of the program. Unfortunately SystemView does not support tracing from multiple cores. So when tracing from ESP32 working in dual-core mode two files are generated: one for PRO CPU and another one for APP CPU. User can load every file into separate instance of the tool.</p>
<p>It is uneasy and awkward to analyze data for every core in separate instance of the tool. Fortunately there is Eclipse plugin called <em>Impulse</em> which can load several trace files and makes its possible to inspect events from both cores in one view. Also this plugin has no limitation of 1000000 events as compared to free version of SystemView.</p>
<p>Good instruction on how to install, configure and visualize data in Impulse from one core can be found <a class="reference external" href="https://mcuoneclipse.com/2016/07/31/impulse-segger-systemview-in-eclipse/">here</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">IDF uses its own mapping for SystemView FreeRTOS events IDs, so user needs to replace original file with mapping <code class="docutils literal"><span class="pre">$SYSVIEW_INSTALL_DIR/Description/SYSVIEW_FreeRTOS.txt</span></code> with <code class="docutils literal"><span class="pre">$IDF_PATH/docs/api-guides/SYSVIEW_FreeRTOS.txt</span></code>.
Also contents of that IDF specific file should be used when configuring SystemView serializer using above link.</p>
</div>
<div class="section" id="configure-impulse-for-dual-core-traces">
<h5>Configure Impulse for Dual Core Traces<a class="headerlink" href="app_trace.html#configure-impulse-for-dual-core-traces" title="Permalink to this headline">¶</a></h5>
<p>After installing Impulse and ensuring that it can successfully load trace files for each core in separate tabs user can add special Multi Adapter port and load both files into one view. To do this user needs to do the following in Eclipse:</p>
<ol class="arabic simple">
<li>Open &#8216;Signal Ports&#8217; view. Go to Windows-&gt;Show View-&gt;Other menu. Find &#8216;Signal Ports&#8217; view in Impulse folder and double-click on it.</li>
<li>In &#8216;Signal Ports&#8217; view right-click on &#8216;Ports&#8217; and select &#8216;Add ...&#8217;-&gt;New Multi Adapter Port</li>
<li>In open dialog Press &#8216;Add&#8217; button and select &#8216;New Pipe/File&#8217;.</li>
<li>In open dialog select &#8216;SystemView Serializer&#8217; as Serializer and set path to PRO CPU trace file. Press OK.</li>
<li>Repeat steps 3-4 for APP CPU trace file.</li>
<li>Double-click on created port. View for this port should open.</li>
<li>Click Start/Stop Streaming button. Data should be loaded.</li>
<li>Use &#8216;Zoom Out&#8217;, &#8216;Zoom In&#8217; and &#8216;Zoom Fit&#8217; button to inspect data.</li>
<li>For settings measurement cursors and other features please see <a class="reference external" href="http://toem.de/index.php/projects/impulse">Impulse documentation</a>).</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you have problems with visualization (no data are shown or strange behaviour of zoom action is observed) you can try to delete current signal hierarchy and double click on necessary file or port. Eclipse will ask you to create new signal hierarchy.</p>
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="partition-tables.html" class="btn btn-neutral float-right" title="Partition Tables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="jtag-debugging/tips-and-quirks.html" class="btn btn-neutral" title="Tips and Quirks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016 - 2017, Espressif.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'v3.0-dev-806-gde750e9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>